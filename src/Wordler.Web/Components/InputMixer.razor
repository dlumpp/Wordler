@using Wordler.Core;
@using Wordler.Web.Components;

@inject IMixerService MixerService;

<div>
    @for (int i = 0; i < YellowWordCount; i++)
    {
        var wordIndex = i;
        <WordInput WordChanged="@(word => YellowWordChangedAsync(word, wordIndex))" Status="LetterStatus.Yellow" />
    }
    <button @onclick="@(() => YellowWordCount++)">+</button>
</div>

<div>
    <WordInput WordChanged="@GreenWordChangedAsync" Status="LetterStatus.Green" />
</div>

@code {
    [Parameter]
    public EventCallback<IEnumerable<string>> PossibilitesChanged { get; set; }

    int YellowWordCount = 1;

    Dictionary<int, IEnumerable<LetterSpace>> YellowWords = new ();

    IEnumerable<LetterSpace>? GreenWord;

    async Task YellowWordChangedAsync(LetterSpace?[] word, int wordIndex)
    {
        YellowWords[wordIndex] = WhereNotNull(word);
        await RecalcPossibilitiesAsync();
    }

    async Task GreenWordChangedAsync(LetterSpace?[] word)
    {
        GreenWord = WhereNotNull(word);
        await RecalcPossibilitiesAsync();
    }

    IEnumerable<LetterSpace> WhereNotNull(IEnumerable<LetterSpace?> values) =>
        values.Where(l => l is not null && l.Value is not null)
            .Cast<LetterSpace>();

    async Task RecalcPossibilitiesAsync()
    {
        var letters = EmptyIfNull(AggregateYellowKnowledge()).Concat(EmptyIfNull(GreenWord));
        var mix = MixerService.Mix(letters).Select(LettersToWord).ToList();
        await PossibilitesChanged.InvokeAsync(mix);
    }

    IEnumerable<LetterSpace> AggregateYellowKnowledge()
    {
        var agg = new List<LetterSpace>();
        foreach (var word in YellowWords.Values)
        {
            //spread the same "not at" info to all repeat letters within the same word
            var repeatLetters = word.GroupBy(l => l.Value).Where(g => g.Count() > 1);
            var notIndexes = repeatLetters.SelectMany(l => l.SelectMany(m => m.NotAt)).ToHashSet();
            foreach (var letterGroup in repeatLetters)
            {
                foreach (var repeatLetter in letterGroup)
                {
                    repeatLetter.NotAt = notIndexes.ToList();
                    agg.Add(repeatLetter);
                }
            }
            //aggregate non-repeats
            var remainingLetters = word.Except(agg);
            foreach (var letter in remainingLetters)
            {
                var match = agg.SingleOrDefault(l => l.Value == letter.Value);
                if(match is null)
                {                    
                    agg.Add(letter);
                }
                else 
                {
                    foreach (var notAt in letter.NotAt)
                    {
                        if (!match.NotAt.Contains(notAt))
                        {
                            match.NotAt.Add(notAt);
                        }
                    }
                }
            }
        }
        return agg;
        //var letterGroups = YellowWords.Values.SelectMany(word => word).GroupBy(l => l.Value);
        //return letterGroups.Select(lg => 
        //    new LetterSpace 
        //    { 
        //        Value = lg.Key, 
        //        NotAt = lg.SelectMany(n => n.NotAt).Distinct().ToList() 
        //    });
    }

    IEnumerable<T> EmptyIfNull<T>(IEnumerable<T>? values) => values ?? Array.Empty<T>();

    string LettersToWord(IEnumerable<char?> letters) =>
        new(letters.Select(l => l ?? '_').ToArray());
}